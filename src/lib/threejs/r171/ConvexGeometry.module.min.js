import{BufferGeometry as z,Float32BufferAttribute as C}from"three";import{Line3 as H,Plane as S,Triangle as j,Vector3 as g}from"three";var T=0,I=1,N=new g,b=new H,V=new S,A=new g,F=new j,P=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new E,this.unassigned=new E,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.vertices.push(new M(t[e]));this.compute()}return this}setFromObject(t){let e=[];return t.updateMatrixWorld(!0),t.traverse(function(i){let s=i.geometry;if(s!==void 0){let n=s.attributes.position;if(n!==void 0)for(let a=0,o=n.count;a<o;a++){let c=new g;c.fromBufferAttribute(n,a).applyMatrix4(i.matrixWorld),e.push(c)}}}),this.setFromPoints(e)}containsPoint(t){let e=this.faces;for(let i=0,s=e.length;i<s;i++)if(e[i].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){let i=this.faces,s=-1/0,n=1/0;for(let a=0,o=i.length;a<o;a++){let c=i[a],r=c.distanceToPoint(t.origin),d=c.normal.dot(t.direction);if(r>0&&d>=0)return null;let u=d!==0?-r/d:0;if(!(u<=0)&&(d>0?n=Math.min(u,n):s=Math.max(u,s),s>n))return null}return s!==-1/0?t.at(s,e):t.at(n,e),e}intersectsRay(t){return this.intersectRay(t,N)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){let e=t.outside,i=t.outside;for(;i.next!==null&&i.next.face===t;)i=i.next;return this.assigned.removeSubList(e,i),e.prev=i.next=null,t.outside=null,e}}deleteFaceVertices(t,e){let i=this.removeAllVerticesFromFace(t);if(i!==void 0)if(e===void 0)this.unassigned.appendChain(i);else{let s=i;do{let n=s.next;e.distanceToPoint(s.point)>this.tolerance?this.addVertexToFace(s,e):this.unassigned.append(s),s=n}while(s!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{let i=e.next,s=this.tolerance,n=null;for(let a=0;a<t.length;a++){let o=t[a];if(o.mark===T){let c=o.distanceToPoint(e.point);if(c>s&&(s=c,n=o),s>1e3*this.tolerance)break}}n!==null&&this.addVertexToFace(e,n),e=i}while(e!==null)}return this}computeExtremes(){let t=new g,e=new g,i=[],s=[];for(let n=0;n<3;n++)i[n]=s[n]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let n=0,a=this.vertices.length;n<a;n++){let o=this.vertices[n],c=o.point;for(let r=0;r<3;r++)c.getComponent(r)<t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),i[r]=o);for(let r=0;r<3;r++)c.getComponent(r)>e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),s[r]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:i,max:s}}computeInitialHull(){let t=this.vertices,e=this.computeExtremes(),i=e.min,s=e.max,n=0,a=0;for(let l=0;l<3;l++){let p=s[l].point.getComponent(l)-i[l].point.getComponent(l);p>n&&(n=p,a=l)}let o=i[a],c=s[a],r,d;n=0,b.set(o.point,c.point);for(let l=0,p=this.vertices.length;l<p;l++){let h=t[l];if(h!==o&&h!==c){b.closestPointToPoint(h.point,!0,A);let m=A.distanceToSquared(h.point);m>n&&(n=m,r=h)}}n=-1,V.setFromCoplanarPoints(o.point,c.point,r.point);for(let l=0,p=this.vertices.length;l<p;l++){let h=t[l];if(h!==o&&h!==c&&h!==r){let m=Math.abs(V.distanceToPoint(h.point));m>n&&(n=m,d=h)}}let u=[];if(V.distanceToPoint(d.point)<0){u.push(f.create(o,c,r),f.create(d,c,o),f.create(d,r,c),f.create(d,o,r));for(let l=0;l<3;l++){let p=(l+1)%3;u[l+1].getEdge(2).setTwin(u[0].getEdge(p)),u[l+1].getEdge(1).setTwin(u[p+1].getEdge(0))}}else{u.push(f.create(o,r,c),f.create(d,o,c),f.create(d,c,r),f.create(d,r,o));for(let l=0;l<3;l++){let p=(l+1)%3;u[l+1].getEdge(2).setTwin(u[0].getEdge((3-l)%3)),u[l+1].getEdge(0).setTwin(u[p+1].getEdge(1))}}for(let l=0;l<4;l++)this.faces.push(u[l]);for(let l=0,p=t.length;l<p;l++){let h=t[l];if(h!==o&&h!==c&&h!==r&&h!==d){n=this.tolerance;let m=null;for(let v=0;v<4;v++){let y=this.faces[v].distanceToPoint(h.point);y>n&&(n=y,m=this.faces[v])}m!==null&&this.addVertexToFace(h,m)}}return this}reindexFaces(){let t=[];for(let e=0;e<this.faces.length;e++){let i=this.faces[e];i.mark===T&&t.push(i)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0,i=this.assigned.first().face,s=i.outside;do{let n=i.distanceToPoint(s.point);n>e&&(e=n,t=s),s=s.next}while(s!==null&&s.face===i);return t}}computeHorizon(t,e,i,s){this.deleteFaceVertices(i),i.mark=I;let n;e===null?n=e=i.getEdge(0):n=e.next;do{let a=n.twin,o=a.face;o.mark===T&&(o.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,a,o,s):s.push(n)),n=n.next}while(n!==e);return this}addAdjoiningFace(t,e){let i=f.create(t,e.tail(),e.head());return this.faces.push(i),i.getEdge(-1).setTwin(e.twin),i.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let i=null,s=null;for(let n=0;n<e.length;n++){let a=e[n],o=this.addAdjoiningFace(t,a);i===null?i=o:o.next.setTwin(s),this.newFaces.push(o.face),s=o}return i.next.setTwin(s),this}addVertexToHull(t){let e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}},f=class x{constructor(){this.normal=new g,this.midpoint=new g,this.area=0,this.constant=0,this.outside=null,this.mark=T,this.edge=null}static create(t,e,i){let s=new x,n=new w(t,s),a=new w(e,s),o=new w(i,s);return n.next=o.prev=a,a.next=n.prev=o,o.next=a.prev=n,s.edge=n,s.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){let t=this.edge.tail(),e=this.edge.head(),i=this.edge.next.head();return F.set(t.point,e.point,i.point),F.getNormal(this.normal),F.getMidpoint(this.midpoint),this.area=F.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}},w=class{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){let t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){let t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}},M=class{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}},E=class{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}};var k=class extends z{constructor(t=[]){super();let e=[],i=[],n=new P().setFromPoints(t).faces;for(let a=0;a<n.length;a++){let o=n[a],c=o.edge;do{let r=c.head().point;e.push(r.x,r.y,r.z),i.push(o.normal.x,o.normal.y,o.normal.z),c=c.next}while(c!==o.edge)}this.setAttribute("position",new C(e,3)),this.setAttribute("normal",new C(i,3))}};export{k as ConvexGeometry,P as ConvexHull};
